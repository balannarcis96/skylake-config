//!
//! \file skl_config
//!
//! \license Licensed under the MIT License. See LICENSE for details.
//!
#pragma once

#include <memory>
#include <filesystem>
#include <fstream>

#include <skl_log>
#include <skl_string_view>

#include <nlohmann/json.hpp>

#include "skl_config_internal/numeric_field.hpp"
#include "skl_config_internal/string_field.hpp"
#include "skl_config_internal/array_field.hpp"
#include "skl_config_internal/object_field.hpp"

#define SKL_LOG_TAG ""

namespace skl {
using json = nlohmann::json;

template <config::CConfigTargetType _TargetConfig>
class ConfigNode final : public config::Field {
public:
    using field_t = config::ConfigField<_TargetConfig>;

    ConfigNode() noexcept
        : Field(nullptr, "__root__") { }

    ~ConfigNode() override = default;

    ConfigNode(const ConfigNode& f_other)
        : config::Field(f_other) {
        m_fields.reserve(f_other.m_fields.size());

        for (const auto& field : f_other.m_fields) {
            auto clone = field->clone();
            clone->update_parent(*this);
            m_fields.emplace_back(std::move(clone));
        }
    }

    ConfigNode& operator=(const ConfigNode& f_other) {
        if (&f_other == this) {
            return *this;
        }

        m_fields.clear();
        m_fields.reserve(f_other.m_fields.size());

        for (const auto& field : f_other.m_fields) {
            auto clone = field->clone();
            clone->update_parent(*this);
            m_fields.emplace_back(std::move(clone));
        }

        return *this;
    }

    ConfigNode(ConfigNode&& f_other) noexcept
        : config::Field(std::move(f_other))
        , m_fields(std::move(f_other.m_fields)) {

        for (auto& field : m_fields) {
            field->update_parent(*this);
        }
    }

    ConfigNode& operator=(ConfigNode&& f_other) noexcept {
        if (&f_other == this) {
            return *this;
        }

        m_fields.clear();
        m_fields = std::move(f_other.m_fields);

        for (auto& field : m_fields) {
            field->update_parent(*this);
        }

        return *this;
    }

    /*=== char[] ===*/

    template <u32 _N>
        requires(_N > 1U)
    config::StringField<char[_N], _TargetConfig>& string(skl_string_view f_field_name, char (_TargetConfig::*f_member_ptr)[_N]) {
        for (const auto& field : m_fields) {
            if (field->name() == f_field_name.std<std::string_view>()) {
                SERROR_LOCAL_T("Field \"{}\" was already registered!", f_field_name);
                throw std::runtime_error("Duplicate value field registration");
            }
        }

        m_fields.emplace_back(std::make_unique<config::StringField<char[_N], _TargetConfig>>(this, f_field_name.std<std::string_view>(), f_member_ptr));
        return static_cast<config::StringField<char[_N], _TargetConfig>&>(*m_fields.back());
    }

    template <u32 _K, u32 _N>
        requires((_N > 1U) && (_K > 1U))
    config::StringField<char[_N], _TargetConfig>& string(const char (&f_field_name)[_K], char (_TargetConfig::*f_member_ptr)[_N]) {
        return string(skl_string_view::exact_cstr(f_field_name), f_member_ptr);
    }

    /*=== std::string ===*/

    config::StringField<std::string, _TargetConfig>& string(skl_string_view f_field_name, config::StringField<std::string, _TargetConfig>::member_ptr_t f_member_ptr) {
        for (const auto& field : m_fields) {
            if (field->name() == f_field_name.std<std::string_view>()) {
                SERROR_LOCAL_T("Field \"{}\" was already registered!", f_field_name);
                throw std::runtime_error("Duplicate value field registration");
            }
        }

        m_fields.emplace_back(std::make_unique<config::StringField<std::string, _TargetConfig>>(this, f_field_name.std<std::string_view>(), f_member_ptr));
        return static_cast<config::StringField<std::string, _TargetConfig>&>(*m_fields.back());
    }

    template <u32 _K>
        requires(_K > 1U)
    config::StringField<std::string, _TargetConfig>& string(const char (&f_field_name)[_K], config::StringField<std::string, _TargetConfig>::member_ptr_t f_member_ptr) {
        return string(skl_string_view::exact_cstr(f_field_name), f_member_ptr);
    }

    /*=== numeric ===*/

    template <config::CNumericValueFieldType _Field>
    config::NumericField<_Field, _TargetConfig>& numeric(skl_string_view f_field_name, config::NumericField<_Field, _TargetConfig>::member_ptr_t f_member_ptr) {
        for (const auto& field : m_fields) {
            if (field->name() == f_field_name.std<std::string_view>()) {
                SERROR_LOCAL_T("Field \"{}\" was already registered!", f_field_name);
                throw std::runtime_error("Duplicate value field registration");
            }
        }

        m_fields.emplace_back(std::make_unique<config::NumericField<_Field, _TargetConfig>>(this, f_field_name.std<std::string_view>(), f_member_ptr));
        return static_cast<config::NumericField<_Field, _TargetConfig>&>(*m_fields.back());
    }

    template <config::CNumericValueFieldType _Field, u32 _N>
    config::NumericField<_Field, _TargetConfig>& numeric(const char (&f_field_name)[_N], config::NumericField<_Field, _TargetConfig>::member_ptr_t f_member_ptr) {
        return numeric<_Field>(skl_string_view::exact_cstr(f_field_name), f_member_ptr);
    }

    /*=== object ===*/

    template <config::CConfigTargetType _ChildTargetConfig>
    config::ObjectField<_ChildTargetConfig, _TargetConfig>& object(skl_string_view                                                      f_field_name,
                                                                   config::ObjectField<_ChildTargetConfig, _TargetConfig>::member_ptr_t f_member_ptr,
                                                                   ConfigNode<_ChildTargetConfig>                                       f_config) {
        for (const auto& field : m_fields) {
            if (field->name() == f_field_name.std<std::string_view>()) {
                SERROR_LOCAL_T("Field \"{}\" was already registered!", f_field_name);
                throw std::runtime_error("Duplicate value field registration");
            }
        }

        f_config.set_parent(f_field_name.std<std::string_view>(), *this);
        m_fields.emplace_back(std::make_unique<config::ObjectField<_ChildTargetConfig, _TargetConfig>>(this, f_field_name.std<std::string_view>(), f_member_ptr, std::move(f_config)));
        return static_cast<config::ObjectField<_ChildTargetConfig, _TargetConfig>&>(*m_fields.back());
    }

    template <config::CConfigTargetType _ChildTargetConfig, u32 _N>
    config::ObjectField<_ChildTargetConfig, _TargetConfig>& object(const char (&f_field_name)[_N],
                                                                   config::ObjectField<_ChildTargetConfig, _TargetConfig>::member_ptr_t f_member_ptr,
                                                                   const ConfigNode<_ChildTargetConfig>&                                f_config) {
        return object<_ChildTargetConfig>(skl_string_view::exact_cstr(f_field_name), f_member_ptr, f_config);
    }

    template <config::CConfigTargetType _ChildTargetConfig, u32 _N>
    config::ObjectField<_ChildTargetConfig, _TargetConfig>& object(const char (&f_field_name)[_N],
                                                                   config::ObjectField<_ChildTargetConfig, _TargetConfig>::member_ptr_t f_member_ptr,
                                                                   ConfigNode<_ChildTargetConfig>&&                                     f_config) {
        return object<_ChildTargetConfig>(skl_string_view::exact_cstr(f_field_name), f_member_ptr, std::move(f_config));
    }

    /*=== array ===*/

    template <config::CConfigTargetType _ChildTargetConfig, template <typename> typename _Container = std::vector>
    config::ArrayField<_ChildTargetConfig, _TargetConfig, _Container>& array(skl_string_view                                                                 f_field_name,
                                                                             config::ArrayField<_ChildTargetConfig, _TargetConfig, _Container>::member_ptr_t f_member_ptr,
                                                                             ConfigNode<_ChildTargetConfig>                                                  f_config) {
        for (const auto& field : m_fields) {
            if (field->name() == f_field_name.std<std::string_view>()) {
                SERROR_LOCAL_T("Field \"{}\" was already registered!", f_field_name);
                throw std::runtime_error("Duplicate value field registration");
            }
        }

        f_config.set_parent(f_field_name.std<std::string_view>(), *this);
        m_fields.emplace_back(std::make_unique<config::ArrayField<_ChildTargetConfig, _TargetConfig, _Container>>(this, f_field_name.std<std::string_view>(), f_member_ptr, std::move(f_config)));
        return static_cast<config::ArrayField<_ChildTargetConfig, _TargetConfig, _Container>&>(*m_fields.back());
    }

    template <config::CConfigTargetType _ChildTargetConfig, template <typename> typename _Container = std::vector, u32 _N>
    config::ArrayField<_ChildTargetConfig, _TargetConfig, _Container>& array(const char (&f_field_name)[_N],
                                                                             config::ArrayField<_ChildTargetConfig, _TargetConfig, _Container>::member_ptr_t f_member_ptr,
                                                                             const ConfigNode<_ChildTargetConfig>&                                           f_config) {
        return array<_ChildTargetConfig, _Container>(skl_string_view::exact_cstr(f_field_name), f_member_ptr, f_config);
    }

    template <config::CConfigTargetType _ChildTargetConfig, template <typename> typename _Container = std::vector, u32 _N>
    config::ArrayField<_ChildTargetConfig, _TargetConfig, _Container>& array(const char (&f_field_name)[_N],
                                                                             config::ArrayField<_ChildTargetConfig, _TargetConfig, _Container>::member_ptr_t f_member_ptr,
                                                                             ConfigNode<_ChildTargetConfig>&&                                                f_config) {
        return array<_ChildTargetConfig, _Container>(skl_string_view::exact_cstr(f_field_name), f_member_ptr, std::move(f_config));
    }

    void load_validate_and_submit(skl_string_view f_file, _TargetConfig& f_out_config) {
        load_from_file(f_file);
        validate();
        submit(f_out_config);
        reset();
    }

    void validate_only(const _TargetConfig& f_config) {
        load_fields_for_validation_only(f_config);
        validate();
        reset();
    }

    //! Reset all the loaded state
    void reset() override {
        for (auto& field : m_fields) {
            field->reset();
        }
    }

    //! Clear all configured fields, objects and arrays
    void clear() {
        m_fields.clear();
    }

private:
    void load(json& f_json) {
        bool failed = false;
        for (auto& field : m_fields) {
            try {
                field->load(f_json);
            } catch (const std::exception& f_ex) {
                failed = true;
            }
        }

        if (failed) {
            throw std::runtime_error("Load failed for config!");
        }
    }

    void load_from_file(skl::skl_string_view f_json_file) {
        if (false == std::filesystem::exists(f_json_file.std<std::string_view>())) {
            SERROR_LOCAL_T("File \"{}\" does not exist!", f_json_file);
            throw std::runtime_error("File doesn't exists");
        }

        if (false == std::filesystem::is_regular_file(f_json_file.std<std::string_view>())) {
            SERROR_LOCAL_T("File \"{}\" must be a json file!", f_json_file);
            throw std::runtime_error("Invalid json file");
        }

        std::string file_name{};
        file_name += f_json_file.std<std::string_view>();
        std::ifstream file{file_name};
        if ((false == file.is_open()) || file.bad()) {
            SERROR_LOCAL_T("Failed to open \"{}\" file!", f_json_file);
            throw std::runtime_error("File open failed");
        }

        json j = json::parse(file);
        load(j);
    }

    void validate() {
        bool failed = false;
        for (auto& field : m_fields) {
            try {
                field->validate();
            } catch (const std::exception& f_ex) {
                failed = true;
            }
        }

        if (failed) {
            throw std::runtime_error("Validaton failed for config!");
        }
    }

    void submit(_TargetConfig& f_out_config) {
        for (auto& field : m_fields) {
            field->submit(f_out_config);
        }
    }

    void set_parent(std::string_view f_field_name, config::Field& f_parent) noexcept {
        this->m_name   = f_field_name;
        this->m_parent = &f_parent;
    }

    void load_fields_from_default_object(const _TargetConfig& f_config) {
        for (auto& field : m_fields) {
            field->load_value_from_default_object(f_config);
        }
    }

    void load_fields_for_validation_only(const _TargetConfig& f_config) {
        for (auto& field : m_fields) {
            field->load_value_for_validation_only(f_config);
        }
    }

private:
    std::vector<std::unique_ptr<config::ConfigField<_TargetConfig>>> m_fields;

    template <config::CConfigTargetType, config::CConfigTargetType>
    friend class config::ObjectField;

    template <config::CConfigTargetType, config::CConfigTargetType, template <typename> typename>
    friend class config::ArrayField;

    template <config::CConfigTargetType>
    friend class ConfigNode;
};

} // namespace skl

#undef SKL_LOG_TAG
